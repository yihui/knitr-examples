---
title: About `exec` engine
editor: visual 
---

# How does this engine works ?

The `exec` engine allows to execute an arbitrary command on the code chunk content, optionally with arguments. If any, they are passed to `engine.opts` and they could be one of the following:

``` r
engine.opts = list(command, file, ext, clean, args, args1, args2)
```

The execution of the chunk will be equivalent to this command line

    <command> <args1> <args> <args2>

Behavior by default, during evaluation will be:

-   Retrieve the path of the command in `command` option.
-   Write the chunk content into a temporary file `f`
-   Register the `clean` function to execute on exit, basically to remove the temp file `f`.
-   Compute the argument of the command line by appending the results of `args1()`, with `args()` then `args2()`.

There should be very rare usage of changing the default behavior, but it can be useful to debug for example or other advanced usage.

You can find some examples below on how to use each option. We are using `Rscript` an d `python` only in the examples below by convenience but this work with any executable file.

# Simple example

`command` can be the name of a command in PATH.

```{exec, command='Rscript'}
1 + 1
```

```{exec, command='python'}
print(1 + 1)
```

or a full path

```{exec, command = Sys.which('python'), message = FALSE}
print("Full path command works")
```

It can also be passed as an option in `engine.opts`.

```{exec, engine.opts = list(command ='python')}
print(1 + 1)
```

It is the only option that can be passed as first level chunk option.

# Options

All other options should be provided in the chunk option `engine.opts` in a list. (As seen above, `command` can be optionally in `engine.opts`, too).

They can take character values or functions that returns character values.

## file

It returns the temporary file path that will be used for execution by the command.

It is a function of two argument `function(code, file){}` - By default, function is writing `code` into the temporary file `file` that will be executed by the command. This can be change if needed for other side effect. You would still want to write the `code` into a file (using `xfun::write_utf8()` or another function) otherwise the command will be executed with an empty file.

```{r}
file2 <- function(code, file) {
  xfun::write_utf8("print('file2 executed')", file)
  file
}
```

```{exec, engine.opts=list(command = 'python', file = file2)}
print(1 + 1)
```

## ext

This will determine the extension to use with the temporary file. By default, the extension will be the name of the command file. Use this option to change it.

For example, this will insure the tempfile has a `.R` extension.

```{exec, engine.opts = list(command='Rscript', ext = 'R')}
1 + 1
```

It can be a function of the executable name (i.e `basename(command)`).

```{r, include = FALSE}
ext_fun <- function(name) {
  if (grepl("Rscript", name)) return("R")
  if (grepl("python", name)) return("py")
  name
}
```

```{exec, command = 'python', engine.opts = list(ext = ext_fun)}
print(1 + 1)
```

The extension of the temporary does not really matter most of the time but you can use this option if the command you use needs it.

## args, args1, args2

    <command> <args1()> <args(code, f)> <args2()>

-   `args1` will be the first argument(s) to be passed after the command line.
-   `args` will the main argument passing the temporary filename to the command
-   `args2` will be the last argument(s) to be passed, after the file argument.

`args` will be by default the temporary file name. If customized, it can be a function or 2 arguments `function(code, file)`. In this example, a line is preprended in the file before being run.

```{r}
f_arg <- function(code, file) {
  # prepend a command
  xfun::append_utf8("print('# file modified in args')", file, sort = rev)
  file
}
```

```{exec, engine.opts=list(command = 'python', args = f_arg)}
print(1 + 1)
```

It can be combined with args1 to pass an argument before in the command line. For example, here passing `-x` to `python`, the prepended line will be ignored

```{exec, engine.opts=list(command = 'python', args1 = '-x', args = f_arg)}
print(1 + 1)
```

With setting `args` to a string, you could easily use the exec engine to exectute a string.

We are writing this content to `custom.py`

```{cat, engine.opts = list(file = 'custom.py', lang = 'python')}
print("Hello from a python file!")
```

That we can execute using an empty `exec` engine chunk

```{exec, command = 'python', engine.opts=list(args = 'custom.py'), echo = FALSE}
```

```{r, include = FALSE}
# clean the demo file
unlink('custom.py')
```

`args2` will be passed after. It could be useful if your code contains arguments, for example:

```{exec, command = 'python', engine.opts=list(args2 = 'hello')}
import sys
print('And the argument is: '+sys.argv[1])
```

## clean

By default, the temporary file will be removed. This option can be set to `NULL` to keep this file for example to debug.

```{exec, command = 'python', engine.opts = list(clean = NULL)}
print('This content can be read if you open the file left')
```

A file with extension `.python` should be still here

```{r}
f1 <- list.files('.', pattern = "python.*\\.python")
file.exists(f1)
```

```{r, cleaning, include = FALSE}
if (length(f1) == 1) unlink(f1)
```

# Usual knitr option works

## Don't execute

Will output nothing

```{exec, command = 'python', eval = FALSE}
print(1 + 1)
```

## Error is caught

```{exec, command = 'Rscript', error = TRUE}
print(1 + "")
```
